// This file was generated by counterfeiter
package handlersfakes

import (
	"sync"

	"github.com/cloudfoundry/dns-release/src/dns/server/handlers"
	"github.com/cloudfoundry/dns-release/src/dns/server/records/dnsresolver"
	"github.com/miekg/dns"
)

type FakeDomainResolver struct {
	ResolveAnswerStub        func(answerDomain string, questionDomains []string, protocol dnsresolver.Protocol, requestMsg *dns.Msg) *dns.Msg
	resolveAnswerMutex       sync.RWMutex
	resolveAnswerArgsForCall []struct {
		answerDomain    string
		questionDomains []string
		protocol        dnsresolver.Protocol
		requestMsg      *dns.Msg
	}
	resolveAnswerReturns struct {
		result1 *dns.Msg
	}
	resolveAnswerReturnsOnCall map[int]struct {
		result1 *dns.Msg
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDomainResolver) ResolveAnswer(answerDomain string, questionDomains []string, protocol dnsresolver.Protocol, requestMsg *dns.Msg) *dns.Msg {
	var questionDomainsCopy []string
	if questionDomains != nil {
		questionDomainsCopy = make([]string, len(questionDomains))
		copy(questionDomainsCopy, questionDomains)
	}
	fake.resolveAnswerMutex.Lock()
	ret, specificReturn := fake.resolveAnswerReturnsOnCall[len(fake.resolveAnswerArgsForCall)]
	fake.resolveAnswerArgsForCall = append(fake.resolveAnswerArgsForCall, struct {
		answerDomain    string
		questionDomains []string
		protocol        dnsresolver.Protocol
		requestMsg      *dns.Msg
	}{answerDomain, questionDomainsCopy, protocol, requestMsg})
	fake.recordInvocation("ResolveAnswer", []interface{}{answerDomain, questionDomainsCopy, protocol, requestMsg})
	fake.resolveAnswerMutex.Unlock()
	if fake.ResolveAnswerStub != nil {
		return fake.ResolveAnswerStub(answerDomain, questionDomains, protocol, requestMsg)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.resolveAnswerReturns.result1
}

func (fake *FakeDomainResolver) ResolveAnswerCallCount() int {
	fake.resolveAnswerMutex.RLock()
	defer fake.resolveAnswerMutex.RUnlock()
	return len(fake.resolveAnswerArgsForCall)
}

func (fake *FakeDomainResolver) ResolveAnswerArgsForCall(i int) (string, []string, dnsresolver.Protocol, *dns.Msg) {
	fake.resolveAnswerMutex.RLock()
	defer fake.resolveAnswerMutex.RUnlock()
	return fake.resolveAnswerArgsForCall[i].answerDomain, fake.resolveAnswerArgsForCall[i].questionDomains, fake.resolveAnswerArgsForCall[i].protocol, fake.resolveAnswerArgsForCall[i].requestMsg
}

func (fake *FakeDomainResolver) ResolveAnswerReturns(result1 *dns.Msg) {
	fake.ResolveAnswerStub = nil
	fake.resolveAnswerReturns = struct {
		result1 *dns.Msg
	}{result1}
}

func (fake *FakeDomainResolver) ResolveAnswerReturnsOnCall(i int, result1 *dns.Msg) {
	fake.ResolveAnswerStub = nil
	if fake.resolveAnswerReturnsOnCall == nil {
		fake.resolveAnswerReturnsOnCall = make(map[int]struct {
			result1 *dns.Msg
		})
	}
	fake.resolveAnswerReturnsOnCall[i] = struct {
		result1 *dns.Msg
	}{result1}
}

func (fake *FakeDomainResolver) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.resolveAnswerMutex.RLock()
	defer fake.resolveAnswerMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeDomainResolver) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ handlers.DomainResolver = new(FakeDomainResolver)
